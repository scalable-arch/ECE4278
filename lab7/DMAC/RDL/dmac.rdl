// Copyright (c) 2021 Sungkyunkwan University
//
// Authors:
// - Jungrae Kim <dale40@skku.edu>

addrmap DMAC_CFG {
    name = "DMA controller address map";
    desc = "Address map of ECE4278 DRAM controller project";
    reg {
        field {
            desc = "The version of this DMA controller.
				The upper 16 bits represent the major version.
				The middle 8 bits represent the minor version.
				The lowest 8 bits represent the micro version.
			   	This document describes behaviors of major verion 2.";
            sw = r;
            hw = na;
            reset = 32'h0002_0101;
        } version[31:0];
    } DMA_VER @0x0;
    reg {
        field {
            desc = "The start address of the source range.";
            sw = rw;
            hw = r;
            reset = 32'h0000_0000;
        } start_addr[31:0];
    } DMA_SRC @0x100;
    reg {
        field {
            desc = "The start address of the destination range.";
            sw = rw;
            hw = r;
            reset = 32'h0000_0000;
        } start_addr[31:0];
    } DMA_DST;	// Without offset information, this register will
                // have a continous address next to the previous reg (0x104)
    reg {
        field {
            desc = "The number of bytes to be transferred from the source to the destination.";
            sw = rw;
            hw = r;
            reset = 16'h0000;
        } byte_len[15:0];
    } DMA_LEN;	// Without offset information, this register will
                // have a continous address next to the previous reg (0x108)
    reg {
        field {
            desc = "Writing 1 to this field will initiate a DMA transfer based on DMA_SRC, DMA_DST, and DMA_LEN registers.
				Software must not write 1 when there's an on-going transfer.
			   	Writing 0 to this field does not affect operation.";
			sw = w;
			hw = r;
            singlepulse;
            reset = 1'b0;
        } start;
    } DMA_CMD;	// Without offset information, this register will
                // have a continous address next to the previous reg (0x10C)
    reg {
        field {
            desc = "This field is 1 when there's no on-going DMA transfer.
                Software must wait this field to be 1 for a completion of a transfer
                Software must not initiate a DMA transfer when this field is 0.";
            sw = r;
			hw = w;
            reset = 1'b0;
        } done;
    } DMA_STATUS;	// Without offset information,
                // have a continous address next to the previous reg (0x110)
    /*
regfile {
    name = "Rx Buffer Memory Registers";
    desc = "This group of registers provides software access to the ECC control, status, and diagnostic registers for the Rx Buffer Memory.";
    reg {
        name = "Rx Buffer Memory ECC Control Register";
        desc = "This register provides the control bits for the Rx Buffer Memory.";
        field {
            name = "Correct Enable";
            desc = "This bit enables ECC correction.";
            sw = rw;
            hw = r;
            reset = 1'b0;
        } correct_en[0:0];
        field {
            name = "Diagnostic Enable";
            desc = "This bit enables ECC diagnostic mode. When this bit is asserted the write data for the protections bits is provided by the ECC Protection Bits Register.";
            sw = rw;
            hw = r;
            reset = 1'b0;
        } diag_en[1:1];
    } ecc_cntrl_reg @0x0;
    reg {
        name = "Rx Buffer Memory ECC Interrupt Read-Clear Register";
        desc = "This register contains the ECC error interrupt bits for the Rx Buffer Memory. The interrupts bits will be cleared on read.";
        default rclr;
        field {
            name = "ECC Multi-bit Error Interrupt";
            desc = "Set when a multi-bit error occurs.";
            rclr;
            sw = rw;
            hw = w;
            stickybit;
            intr;
        } mbe_int[0:0];
        field {
            name = "ECC Single-bit Error Interrupt";
            desc = "Set when a single-bit error occurs.";
            rclr;
            sw = rw;
            hw = w;
            stickybit;
            intr;
        } sbe_int[1:1];
    } ecc_int_reg @0x2;
    reg {
        name = "Rx Buffer Memory ECC Interrupt Enable Register";
        desc = "This register contains the interrupt enable bits for the Rx Buffer Memory.";
        field {
            name = "ECC Multi-bit Error Interrupt Enable";
            desc = "Enables multi-bit error interrupt";
            sw = rw;
            hw = na;
        } mbe_int_en[0:0];
        field {
            name = "ECC Single-bit Error Interrupt Enable";
            desc = "Enables single-bit error interrupt";
            sw = rw;
            hw = na;
        } sbe_int_en[1:1];
    } ecc_int_en_reg @0x18;
    reg {
        field {
            name = "ECC Multi-Bit Error Interrupt Count";
            desc = "This is a count of the MBE interrupts. This counter is cleared on read.";
            rclr;
            sw = rw;
            hw = na;
            counter;
            incr;
            incrvalue = 8'h1;
        } mbe_int_cnt[7:0];
        field {
            name = "ECC Single-Bit Error Interrupt Count";
            desc = "This is a count of the SBE interrupts. This counter is cleared on read.";
            rclr;
            sw = rw;
            hw = na;
            counter;
            incr;
            incrvalue = 8'h1;
        } sbe_int_cnt[15:8];
    } int_cnt_reg @0x1a;
    reg {
        name = "Rx Buffer Memory ECC Error Address Register";
        desc = "This register contains the address of the read that had an ECC error.";
        field {
            name = "ECC Error Address";
            desc = "This field contains the address of the error";
            sw = rw;
            hw = w;
            we;
        } address[13:0];
    } ecc_err_addr_reg @0x1c;
    reg {
        name = "Rx Buffer Memory Diagnostic Control Register";
        desc = "This register provide the diagnostic control for the Rx Buffer Memory.";
        field {
            sw = rw;
            hw = na;
        } diagnostic_address[13:0];
        field {
            name = "Read Command";
            desc = "If this bit is asserted a read occurs when a diagnostic transaction is initiated.";
            sw = rw;
            hw = r;
        } read[14:14];
        field {
            name = "Initiate";
            desc = "When this bit is asserted it will initiate a transaction to the memory.  If this register is written with this bit deasserted no transaction will occur.  This bit will clear when the memory transaction is completed.";
            sw = rw;
            hw = na;
            hwclr;
        } initiate[15:15];
    } diag_cntrl_reg @0x1e;
    reg {
        name = "Rx Buffer Memory ECC Protection Bits Register";
        desc = "This register provides access to the ECC protection bits for the Rx Buffer Memory.";
        field {
            name = "ECC Value";
            desc = "This field contains the ECC protection bits. This field contains ECC protection bits form the last read. When the diagnostic mode is 1 then this field is used to write the ECC memory bits instead of the calculated protection bits.";
            sw = rw;
            hw = rw;
            reset = 6'b0;
            we;
        } ecc_bits[5:0];
    } ecc_bits_reg @0x20;
    reg {
        name = "Rx Buffer Memory Data Bits Register";
        desc = "This register provides access to the data bits of the Rx Buffer Memory data bits.";
        field {
            name = "Memory data bits";
            desc = "This field provides the read data bit of the memory after every read operation.  When diagnostic mode is asserted this data is used to write the memory.";
            sw = rw;
            hw = w;
            we;
        } data_value[15:0];
    } data_reg @0x40;
} rx_mem_regs[2] @0x100;
regfile {
    name = "Tx Buffer Memory Registers";
    desc = "This group of registers provides software access to the ECC control, status, and diagnostic registers for the Tx Buffer Memory.";
    reg {
        name = "Tx Buffer Memory ECC Control Register";
        desc = "This register provides the control bits for the Tx Buffer Memory.";
        field {
            name = "Correct Enable";
            desc = "This bit enables ECC correction.";
            sw = rw;
            hw = r;
            reset = 1'b0;
        } correct_en[0:0];
        field {
            name = "Diagnostic Enable";
            desc = "This bit enables ECC diagnostic mode. When this bit is asserted the write data for the protections bits is provided by the ECC Protection Bits Register.";
            sw = rw;
            hw = r;
            reset = 1'b0;
        } diag_en[1:1];
    } ecc_cntrl_reg @0x0;
    reg {
        name = "Tx Buffer Memory ECC Interrupt Read-Clear Register";
        desc = "This register contains the ECC error interrupt bits for the Tx Buffer Memory. The interrupts bits will be cleared on read.";
        default rclr;
        field {
            name = "ECC Multi-bit Error Interrupt";
            desc = "Set when a multi-bit error occurs.";
            rclr;
            sw = rw;
            hw = w;
            stickybit;
            intr;
        } mbe_int[0:0];
        field {
            name = "ECC Single-bit Error Interrupt";
            desc = "Set when a single-bit error occurs.";
            rclr;
            sw = rw;
            hw = w;
            stickybit;
            intr;
        } sbe_int[1:1];
    } ecc_int_reg @0x2;
    reg {
        name = "Tx Buffer Memory ECC Interrupt Enable Register";
        desc = "This register contains the interrupt enable bits for the Tx Buffer Memory.";
        field {
            name = "ECC Multi-bit Error Interrupt Enable";
            desc = "Enables multi-bit error interrupt";
            sw = rw;
            hw = na;
        } mbe_int_en[0:0];
        field {
            name = "ECC Single-bit Error Interrupt Enable";
            desc = "Enables single-bit error interrupt";
            sw = rw;
            hw = na;
        } sbe_int_en[1:1];
    } ecc_int_en_reg @0x18;
    reg {
        field {
            name = "ECC Multi-Bit Error Interrupt Count";
            desc = "This is a count of the MBE interrupts. This counter is cleared on read.";
            rclr;
            sw = rw;
            hw = na;
            counter;
            incr;
            incrvalue = 8'h1;
        } mbe_int_cnt[7:0];
        field {
            name = "ECC Single-Bit Error Interrupt Count";
            desc = "This is a count of the SBE interrupts. This counter is cleared on read.";
            rclr;
            sw = rw;
            hw = na;
            counter;
            incr;
            incrvalue = 8'h1;
        } sbe_int_cnt[15:8];
    } int_cnt_reg @0x1a;
    reg {
        name = "Tx Buffer Memory ECC Error Address Register";
        desc = "This register contains the address of the read that had an ECC error.";
        field {
            name = "ECC Error Address";
            desc = "This field contains the address of the error";
            sw = rw;
            hw = w;
            we;
        } address[13:0];
    } ecc_err_addr_reg @0x1c;
    reg {
        name = "Tx Buffer Memory Diagnostic Control Register";
        desc = "This register provide the diagnostic control for the Tx Buffer Memory.";
        field {
            sw = rw;
            hw = na;
        } diagnostic_address[13:0];
        field {
            name = "Read Command";
            desc = "If this bit is asserted a read occurs when a diagnostic transaction is initiated.";
            sw = rw;
            hw = r;
        } read[14:14];
        field {
            name = "Initiate";
            desc = "When this bit is asserted it will initiate a transaction to the memory.  If this register is written with this bit deasserted no transaction will occur.  This bit will clear when the memory transaction is completed.";
            sw = rw;
            hw = na;
            hwclr;
        } initiate[15:15];
    } diag_cntrl_reg @0x1e;
    reg {
        name = "Tx Buffer Memory ECC Protection Bits Register";
        desc = "This register provides access to the ECC protection bits for the Tx Buffer Memory.";
        field {
            name = "ECC Value";
            desc = "This field contains the ECC protection bits. This field contains ECC protection bits form the last read. When the diagnostic mode is 1 then this field is used to write the ECC memory bits instead of the calculated protection bits.";
            sw = rw;
            hw = rw;
            reset = 6'b0;
            we;
        } ecc_bits[5:0];
    } ecc_bits_reg @0x20;
    reg {
        name = "Tx Buffer Memory Data Bits Register";
        desc = "This register provides access to the data bits of the Tx Buffer Memory data bits.";
        field {
            name = "Memory data bits";
            desc = "This field provides the read data bit of the memory after every read operation.  When diagnostic mode is asserted this data is used to write the memory.";
            sw = rw;
            hw = w;
            we;
        } data_value[15:0];
    } data_reg @0x40;
} tx_mem_regs[2] @0x200;
reg {
    name = "Packets Memory";
    desc = "This memory contains the packets.";
    field {
        name = "Data";
        desc = "This field contains the memory data.";
        sw = rw;
        hw = na;
    } data[15:0];
} external pkt_memory[2] @0x300;
pckt_mem_regs.ecc_int_reg.mbe_int->enable = pckt_mem_regs.ecc_int_en_reg.mbe_int_en;
pckt_mem_regs.ecc_int_reg.sbe_int->enable = pckt_mem_regs.ecc_int_en_reg.sbe_int_en;
pckt_mem_regs.int_cnt_reg.mbe_int_cnt->incr = pckt_mem_regs.ecc_int_reg.mbe_int->event;
pckt_mem_regs.int_cnt_reg.sbe_int_cnt->incr = pckt_mem_regs.ecc_int_reg.sbe_int->event;
rx_mem_regs.ecc_int_reg.mbe_int->enable = rx_mem_regs.ecc_int_en_reg.mbe_int_en;
rx_mem_regs.ecc_int_reg.sbe_int->enable = rx_mem_regs.ecc_int_en_reg.sbe_int_en;
rx_mem_regs.int_cnt_reg.mbe_int_cnt->incr = rx_mem_regs.ecc_int_reg.mbe_int->event;
rx_mem_regs.int_cnt_reg.sbe_int_cnt->incr = rx_mem_regs.ecc_int_reg.sbe_int->event;
tx_mem_regs.ecc_int_reg.mbe_int->enable = tx_mem_regs.ecc_int_en_reg.mbe_int_en;
tx_mem_regs.ecc_int_reg.sbe_int->enable = tx_mem_regs.ecc_int_en_reg.sbe_int_en;
tx_mem_regs.int_cnt_reg.mbe_int_cnt->incr = tx_mem_regs.ecc_int_reg.mbe_int->event;
tx_mem_regs.int_cnt_reg.sbe_int_cnt->incr = tx_mem_regs.ecc_int_reg.sbe_int->event;
*/
};
